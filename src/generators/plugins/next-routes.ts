/**
 * Next.js App Router API routes generator
 */

import { FileGenerator, type FileGeneratorOptions } from '../types';
import type { UniversalCommand } from '../../UniversalCommand';

export interface NextRoutesOptions extends FileGeneratorOptions {
  /** Import path for commands (default: '@/commands') */
  commandsImportPath?: string;
  /** Include cache control headers */
  includeCacheHeaders?: boolean;
}

export class NextRoutesGenerator extends FileGenerator<NextRoutesOptions> {
  readonly name = 'next-routes';
  readonly description = 'Generate Next.js App Router API routes';
  readonly outputExtensions = ['.ts', '.js'];

  generateContent(command: UniversalCommand, options: NextRoutesOptions): string {
    const apiRoute = command.toNextAPI();
    const methods = Object.keys(apiRoute);
    const ts = options.typescript !== false;
    const commandVar = command.schema.name.replace(/\s+/g, '_');

    // Serialize schema, handling functions by removing them
    const schemaForSerialization = this.serializeSchema(command.schema);

    return `/**
 * Auto-generated API route: ${command.schema.name}
 * Description: ${command.schema.description}
 *
 * Generated by: @supernal/universal-command (next-routes plugin)
 * DO NOT EDIT MANUALLY
 */

${ts ? "import { NextRequest, NextResponse } from 'next/server';" : ''}
import { UniversalCommand } from '@supernal/universal-command';

const ${commandVar} = new UniversalCommand(${JSON.stringify(schemaForSerialization, null, 2)});

${methods.map(method => `export const ${method} = ${commandVar}.toNextAPI().${method};`).join('\n')}
`;
  }

  getOutputPath(command: UniversalCommand, options: NextRoutesOptions): string {
    const path = require('path');
    const ext = options.typescript !== false ? 'ts' : 'js';
    const routePath = command.getAPIRoutePath();
    return path.join(options.outputDir, routePath, `route.${ext}`);
  }

  /**
   * Serialize schema for code generation, omitting functions
   */
  private serializeSchema(schema: any): any {
    const result: any = {};

    for (const [key, value] of Object.entries(schema)) {
      if (typeof value === 'function') {
        // Skip functions - they'll need to be provided at runtime
        continue;
      } else if (value && typeof value === 'object' && !Array.isArray(value)) {
        result[key] = this.serializeSchema(value);
      } else {
        result[key] = value;
      }
    }

    return result;
  }
}
